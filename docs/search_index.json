[["index.html", "Glossary Overview Offline Access Cite", " Glossary psyTeachR Team 2021-03-27 Overview The glossary defines common jargon you might encounter while learning R. This specialised vocabulary can help you to communicate more efficiently about coding and statistics and to search for solutions to problems. The glossary was developed to link to the PsyTeachR books, but you can link to it from any resource. Suggest additions or changes at the github issues page. Offline Access You can download the glossary for offline access (although we update it frequently). # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;psyteachr/glossary&quot;) glossary::open_glossary() # open a local copy Cite Contents are made available under a CC-BY-SA license. To cite: DeBruine, L., Barr, D. J., McAleer, P., Paterson, H., and the #psyTeachR team (2021). PsyTeachR Glossary (version 2021-03-27). Retrieved from https://psyteachr.github.io/glossary. "],["symbols.html", "Symbols", " Symbols Symbol psyTeachR Term Also Known As () (round) brackets parentheses [] square brackets brackets {} curly brackets squiggly brackets &lt;&gt; chevrons angled brackets / guillemets &lt; less than &gt; greater than &amp; ampersand “and” symbol # hash pound / octothorpe / slash forward slash \\ backslash - dash hyphen / minus _ underscore * asterisk star ^ caret power symbol ~ tilde twiddle / squiggle = equal sign == double equal sign . full stop period / point ! exclamation mark bang / not ? question mark ’ single quote quote / apostrophe \" double quote quote %&gt;% pipe magrittr pipe | vertical bar pipe , comma ; semi-colon : colon @ “at” symbol various hilarious regional terms … ellipsis dots Figure 1: Image by James Chapman/Soundimals "],["a.html", "A absolute path alpha alpha (stats) alpha (graphics) ampersand anti_join argument array aspect ratio assignment operator", " A absolute path A file path that starts with / and is not appended to the working directory For example, if your working directory is /Users/me/study/ and you want to refer to a file in the directory data called faces.csv, the absolute path is /Users/me/study/data/faces.csv. However, you should normally use relative paths in scripts, not absolute paths, which can change when you move a project directory to a new computer or even a new place on your computer. The package R.utils has a function getAbsolutePath() that returns the absolute path of a file path or a file object. R.utils::getAbsolutePath(&quot;../index.Rmd&quot;) #&gt; [1] &quot;/Users/lisad/rproj/psyteachr/index.Rmd&quot; alpha (stats) The cutoff value for making a decision to reject the null hypothesis; (graphics) A value between 0 and 1 used to control the levels of transparency in a plot Can also be a parameter in the beta distribution or refer to Cronbach’s alpha. alpha (stats) If you are using null hypothesis significance testing (NHST), then you need to decide on a cutoff value called alpha for making a decision to reject the null hypothesis. We call p-values below the alpha cutoff significant. In psychology, alpha is traditionally set at \\(\\alpha\\) = .05, but there are good arguments for setting a different criterion in some circumstances. alpha (graphics) A value between 0 and 1 used to control the levels of transparency in a plot # if you omit alpha, it defaults to 1 alpha1.00 &lt;- ggplot(diamonds, aes(x = depth, fill = cut)) + geom_density() + xlim(55, 70) alpha0.25 &lt;- ggplot(diamonds, aes(x = depth, fill = cut)) + geom_density(alpha = 0.25) + xlim(55, 70) cowplot::plot_grid(alpha1.00, alpha0.25, nrow = 2, labels = c(&quot;alpha = 1.0&quot;, &quot;alpha = 0.25&quot;)) Figure 2: Setting alpha to a number lower than 1 lets you see parts of the plot hidden behind an object. ampersand The symbol &amp;, an operator meaning “AND.” A single ampersand is vectorized, so compares each item in the first vector with the corresponding item in the second vector. c(T, T, F, F) &amp; c(T, T, F, F) #&gt; [1] TRUE TRUE FALSE FALSE A double ampersand is not vectorised, so will ignore all but the first item in vectors. c(T, T, F, F) &amp;&amp; c(T, T, F, F) #&gt; [1] TRUE The advantage of a double ampersand is that it will stop as soon as the conclusion is obvious. So if the first item is FALSE, the second item won’t even be run. This is useful for testing whether an object exists before checking something that requires the object to exist. if (is.character(x)) { # do something } #&gt; Error in eval(expr, envir, enclos): object &#39;x&#39; not found if (exists(&quot;x&quot;) &amp;&amp; is.character(x)) { # do something } anti_join A filtering join that returns all rows from the left table where there are not matching values in the right table, keeping just columns from the left table. Figure 3: Anti Join This is useful when you have a table of data that contains IDs you want to exclude from your main dataset. all_data &lt;- tibble( id = 1:5, x = LETTERS[1:5] ) to_exclude &lt;- tibble( id = 2:4 ) data &lt;- anti_join(all_data, to_exclude, by = &quot;id&quot;) id x 1 A 5 E See joins for other types of joins and further resources. argument A variable that provides input to a function. For example, the first argument to the function rnorm() is n (the number of observations). When you look up the help for a function (e.g., ?sd), you will see a section called Arguments, which lists the argument names and their definitions. The function args() will show you the argument names and their default values (if any) for any function. args(rnorm) #&gt; function (n, mean = 0, sd = 1) #&gt; NULL array A container that stores objects in one or more dimensions. You can create an array by specifying a list or vector of values and the number of dimensions. The first two dimensions are rows and columns; each dimension after that is printed separately as a facet. # 3-dimensional array with 4 rows, 3 columns, and 2 facets array(1:24, dim = c(4, 3, 2)) #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 13 17 21 #&gt; [2,] 14 18 22 #&gt; [3,] 15 19 23 #&gt; [4,] 16 20 24 You can give your array dimensions names. dimnames &lt;- list( subj_id = c(&quot;S1&quot;, &quot;S2&quot;, &quot;S3&quot;, &quot;S4&quot;), face_id = c(&quot;F1&quot;, &quot;F2&quot;, &quot;F3&quot;), condition = c(&quot;Control&quot;, &quot;experimental&quot;) ) array(1:24, dim = c(4, 3, 2), dimnames = dimnames) #&gt; , , condition = Control #&gt; #&gt; face_id #&gt; subj_id F1 F2 F3 #&gt; S1 1 5 9 #&gt; S2 2 6 10 #&gt; S3 3 7 11 #&gt; S4 4 8 12 #&gt; #&gt; , , condition = experimental #&gt; #&gt; face_id #&gt; subj_id F1 F2 F3 #&gt; S1 13 17 21 #&gt; S2 14 18 22 #&gt; S3 15 19 23 #&gt; S4 16 20 24 Objects not need to be the same data type. mylist &lt;- list(&quot;A&quot;, TRUE, 2L, 3.1) myarray &lt;- array(mylist, dim = c(2,2)) c( myarray[[1,1]] %&gt;% class(), myarray[[1,2]] %&gt;% class(), myarray[[2,1]] %&gt;% class(), myarray[[2,2]] %&gt;% class() ) #&gt; [1] &quot;character&quot; &quot;integer&quot; &quot;logical&quot; &quot;numeric&quot; aspect ratio The ratio between the width and height of an image. You can specify the aspect ratio of your plots by setting the width and height in the first chunk of an R Markdown file like this: knitr::opts_chunk$set( fig.width = 7, # default value is 7 fig.height = 7/1.618 # rolden ratio; default value is 7 ) Or in the chunk options: ```{r fig-golden-ratio, fig.width = 7, fig.height = 4.32} ggplot(iris, aes(Sepal.Width, Sepal.Length, color = Species)) + geom_point() + geom_smooth(method = lm, formula = y~x) ``` Figure 4: Plot with a 1.618:1 aspect ratio (golden ratio) ```{r fig-square, fig.width = 7, fig.height = 7} ggplot(iris, aes(Sepal.Width, Sepal.Length, color = Species)) + geom_point() + geom_smooth(method = lm, formula = y~x) ``` Figure 5: Plot with a 1:1 aspect ratio Or when you save the image: ggsave(&quot;golden-ratio.jpg&quot;, width = 7, height = 7/1.618) assignment operator The symbol &lt;-, which functions like = and assigns the value on the right to the object on the left a &lt;- 1 a #&gt; [1] 1 The assignment operator can also be reversed 2 -&gt; b b #&gt; [1] 2 "],["b.html", "B base R beta distribution beta between subjects bind_cols bind_rows binding joins binomial distribution bivariate normal block brackets", " B base R The set of R functions that come with a basic installation of R, before you add external packages Contrast with tidyverse. beta distribution A family of distributions of data that are characterised by two parameters: α and β Wikipedia actually has really good definitions and examples. beta The false negative rate we accept for a statistical test. Beta is equal to 1 - power, so if a test has power of 0.8 for a specific effect size and alpha, then beta = 0.2. Beta can also refer to a parameter of the beta distribution between subjects Not varying within unit of observation, such that each has only one value For example, imagine an experiment where you test half of subjects in a dark room and the other half in a light. This experiment has one factor, room darkness, which is between subjects because each subject only experiences one level of room darkness, not both. This experiment may also be described as “between subjects.” Contrast with within subjects. bind_cols A binding join that joins one table to another by adding their columns together bind_cols takes two tables with the same number of rows and adds the columns from the second table to the first. a &lt;- tibble( id = 1:3, x = LETTERS[1:3] ) b &lt;- tibble( y = c(T, T, F) ) data &lt;- dplyr::bind_cols(a, b) id x y 1 A TRUE 2 B TRUE 3 C FALSE If any column has the same name in both tables, you will see a warning that the columns have been given new names. a &lt;- tibble( id = 1:3, x = LETTERS[1:3] ) b &lt;- tibble( x = c(T, T, F) ) data &lt;- dplyr::bind_cols(a, b) #&gt; New names: #&gt; * x -&gt; x...2 #&gt; * x -&gt; x...3 id x…2 x…3 1 A TRUE 2 B TRUE 3 C FALSE See joins for other types of joins and further resources. bind_rows A binding join that joins one table to another by adding their rows together bind_rows takes two tables, finds all columns with the same name, and appends the second one to the first. If a column doesn’t have a match in the other table, that columns’ values are set to NA. a &lt;- tibble( id = 1:3, x = LETTERS[1:3], y = c(T, T, F) ) b &lt;- tibble( x = LETTERS[4:6], id = 4:6 ) data &lt;- dplyr::bind_rows(a, b) id x y 1 A TRUE 2 B TRUE 3 C FALSE 4 D NA 5 E NA 6 F NA See joins for other types of joins and further resources. binding joins Joins that bind one table to another by adding their rows or columns together. bind_rows bind_cols binomial distribution The distribution of data where each observation can have one of two outcomes, like success/failure, yes/no or head/tails. # flip 10 coins 10000 times x &lt;- rbinom(10000, 10, prob = 0.5) Figure 6: Binomial Distribution bivariate normal Two normally distributed vectors that have a specified correlation with each other. You can use the {faux} package to quickly create variables from a bivariate normal distribution with a specified correlation. data &lt;- faux::rnorm_multi( n = 10000, vars = 2, mu = 0, sd = 1, r = 0.5, varnames = c(&quot;x&quot;, &quot;y&quot;) ) Figure 7: A bivariate normal distribution where both variables have mu = 0 and SD = 1, with r = 0.5 block A section of code in an R Markdown file See chunk. brackets Square brackets used to subset a container like a vector, list, data frame, or matrix (e.g., mtcars[[1]] or mtcars[1:2]). When you use single brackets to subset a container, you get back a container with the items you selected. This contrasts with double brackets, which only return a single item in the container. You can use single brackets to select one or more items from a vector. secret_code &lt;- c(16, 19, 25, 20, 5, 1, 3, 8, 18) LETTERS[secret_code] #&gt; [1] &quot;P&quot; &quot;S&quot; &quot;Y&quot; &quot;T&quot; &quot;E&quot; &quot;A&quot; &quot;C&quot; &quot;H&quot; &quot;R&quot; If you use double brackets, you can only select a single item from the vector. If you try to select more than one, you will get the following error messge. LETTERS[[secret_code]] #&gt; Error in LETTERS[[secret_code]]: attempt to select more than one element in vectorIndex You can select items by index or name. mylist[c(\"a\", \"c\")] returns a list containing the first and third items. mylist &lt;- list( a = 10, b = 20, c = 30 ) mylist[c(&quot;a&quot;, &quot;c&quot;)] #&gt; $a #&gt; [1] 10 #&gt; #&gt; $c #&gt; [1] 30 Single brackets return the same type of container as the object being subset, so mylist[1] returns a list containing just the first item. mylist[1] #&gt; $a #&gt; [1] 10 Double brackets return the same type of object as the single item being selected, so mylist[[1]] returns a vector that is the same as the first item in mylist. mylist[[1]] #&gt; [1] 10 Single brackets let you select rows and columns of a data frame or tibble, if you separate them by a comma. data &lt;- data.frame( id = 1:3, letter = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), vowel = c(TRUE, FALSE, FALSE) ) # rows 1:2 and columns 3:4 data[1:2, 2:3] #&gt; letter vowel #&gt; 1 a TRUE #&gt; 2 b FALSE If you omit the rows or columns, you select them all. data[1, ] # row 1, all columns #&gt; id letter vowel #&gt; 1 1 a TRUE data[, 1:2] # all rows, columns 1:2 #&gt; id letter #&gt; 1 1 a #&gt; 2 2 b #&gt; 3 3 c If you only select one column of a data frame with single brackets, you will get a vector back instead of a data frame. You can change this behaviour by using drop = FALSE. data[, 1] # returns a vector #&gt; [1] 1 2 3 data[, 1, drop = FALSE] # returns a data frame #&gt; id #&gt; 1 1 #&gt; 2 2 #&gt; 3 3 Tibbles always returns a tibble. as_tibble(data)[, 1] # returns a tibble #&gt; # A tibble: 3 x 1 #&gt; id #&gt; &lt;int&gt; #&gt; 1 1 #&gt; 2 2 #&gt; 3 3 Double brackets can be used with a single index or name to select a column as a vector. data[[&quot;vowel&quot;]] #&gt; [1] TRUE FALSE FALSE Or with row and column values to select a single cell. data[[1, &quot;vowel&quot;]] #&gt; [1] TRUE You can’t use double brackets to select a single row of a data table. data[[1, ]] #&gt; Error in `[[.data.frame`(data, 1, ): argument &quot;..2&quot; is missing, with no default More complex containers like 3-dimensional arrays can have more than 2 values in the brackets, but work on the same principles. myarray &lt;- array(1:8, dim = c(2, 2, 2)) myarray[2, 2, 2] #&gt; [1] 8 "],["c.html", "C categorical character chunk CI coding scheme comment compile computational reproducibility concatenate confidence interval console container continuous correlation matrix correlation covariance matrix CRAN Cronbach’s alpha CSS CSV", " C categorical Data that can only take certain values, such as types of pet. See discrete or nominal. character A data type representing strings of text. Examples of character data are: &quot;I am a string of characters&quot; #&gt; [1] &quot;I am a string of characters&quot; paste(&quot;The answer is &quot;, 6+6) #&gt; [1] &quot;The answer is 12&quot; as.character(100) #&gt; [1] &quot;100&quot; chunk A section of code in an R Markdown file In an Rmd file, you can include a chunk by surrounding the code as in the example below: ```{r chunk-name} mean_age &lt;- mean(ages) %&gt;% round(2) ``` Also sometimes called a block. CI Confidence interval: A type of interval estimate used to summarise a given statistic or measurement where a proportion of intervals calculated from the sample(s) will contain the true value of the statistic. See confidence interval coding scheme How to represent categorical variables with numbers for use in models effect code sum code treatment code (dummy code) Example of different coding schemes for the same data Contrast coding in R by Marissa Barlaz comment You can annotate .R files or chunks in R Markdown files with comments by prefacing each line of the comment with one or more hash symbols (#). # I&#39;m demonstrating comments in this chunk # This comment will be added to the document outline ---- Comments get added to the document outline if you put four or more dashes, equal signs, or hashes at the end. This is a great way to keep track of more complicated scripts. compile To create another resource, such as an app, from source code. Compiling usually refers to taking human-readable code and converting it into code that is more efficient for a computer to run, but that a human can’t read. In the context of R Markdown files, knit, render and compile are sometimes used interchangeably. computational reproducibility The extent to which the findings of a study can be repeated with the same raw data but analyzed by different researchers or by the same researchers on a different occasion. See also reproducibility. concatenate To combine strings or vectors. When referring to strings, concatenate means to add strings together using the function paste (adds a space between strings) or paste0 (doesn’t add anything between strings). subject_name &lt;- &quot;Lisa&quot; paste(&quot;Hello,&quot;, subject_name) #&gt; [1] &quot;Hello, Lisa&quot; When referring to other types of variables, concatenate can mean to create a vector with those variables, usually using the c function. For example, you could concatenate the numbers 1, 3, 6, and 10 like this: c(1, 3, 6, 10). You can concatenate two vectors as well: v1 &lt;- 1:5 v2 &lt;- 11:15 c(v1, v2) #&gt; [1] 1 2 3 4 5 11 12 13 14 15 Remember, a vector can only have one data type. So if you concatenate a string vector and a numeric vector, the numbers will get turned into their string versions. If you concatenate an integer and a double vector, the integers will be converted to doubles. strings &lt;- c(&quot;a&quot;, &quot;c&quot;, &quot;e&quot;) integers &lt;- c(1L, 3L, 5L) doubles &lt;- c(1.1, 3.3, 5.5) c(strings, integers) #&gt; [1] &quot;a&quot; &quot;c&quot; &quot;e&quot; &quot;1&quot; &quot;3&quot; &quot;5&quot; c(doubles, integers) #&gt; [1] 1.1 3.3 5.5 1.0 3.0 5.0 confidence interval A type of interval estimate used to summarise a given statistic or measurement where a proportion of intervals calculated from the sample(s) will contain the true value of the statistic. For example, 95% Confidence Intervals of the mean state that if you were to run the same study on 100 samples and calculate this interval for each iteration of the study, then 95 of the intervals calculated will contain the true mean of the population. Most commonly cited Confidence Intervals are the 95% Confidence Interval and the 99% Confidence Interval. The 95% CI and 99% CI of the mean are calculated as follows: \\(95\\%\\ CI = \\mu ± 1.96 \\times SD\\) \\(99\\%\\ CI = \\mu ± 2.58 \\times SD\\) For example, given \\(\\mu\\) = 10 and \\(SD\\) = 1.25, the \\(95\\%\\ CI = [7.55, 12.45]\\) There are a number of misconceptions about Confidence Intervals and it would be worth reading the following papers: Greenland, S., Senn, S.J., Rothman, K.J. et al. Statistical tests, P values, confidence intervals, and power: a guide to misinterpretations. Eur J Epidemiol 31, 337–350 (2016). https://doi.org/10.1007/s10654-016-0149-3 Hoekstra, R., Morey, R.D., Rouder, J.N. et al. Robust misinterpretation of confidence intervals. Psychon Bull Rev 21, 1157–1164 (2014). https://doi.org/10.3758/s13423-013-0572-3 console The pane in RStudio where you can type in commands and view output messages. Commands typed into the console are not saved in a script, although they may be saved in the history. container A data structure that aggregates data, such as a vector, list, matrix, or data frame # vector c(1,2,3,4) #&gt; [1] 1 2 3 4 # list list(1, &quot;A&quot;, TRUE) #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] &quot;A&quot; #&gt; #&gt; [[3]] #&gt; [1] TRUE # matrix matrix(1:6, nrow = 2) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 # data frame data.frame( id = 1:5, name = c(&quot;Lisa&quot;, &quot;Phil&quot;, &quot;Helena&quot;, &quot;Rachel&quot;, &quot;Jack&quot;) ) #&gt; id name #&gt; 1 1 Lisa #&gt; 2 2 Phil #&gt; 3 3 Helena #&gt; 4 4 Rachel #&gt; 5 5 Jack A container may also refer to a virtual software environment that can be used to make sure that your code has the intended versions of all packages. Docker, Binder and Code Ocean are popular conatiner types. continuous Data that can take on any values between other existing values. As opposed to discrete data, where fractional values don’t make sense, continuous data can take fractional values (as far as the sensitivity of the measurement allows). So even if you are measuring height to the nearest whole centimeter, this is continuous data because it is possible and makes sense for intermediate values to exist. correlation matrix Parameters showing how a set of vectors are correlated. This is set up as a matrix with 1.0 along the diagonal, meaning that every variable is perfectly correlated with itself. data &lt;- tibble( A = rnorm(100), B = rnorm(100), # uncorrelated with A C = rnorm(100) + A, # positively correlated with A D = rnorm(100) - A # negatively correlated with A ) cor(data) # correlation matrix #&gt; A B C D #&gt; A 1.0000000000 -0.0009943199 0.66356312 -0.69155202 #&gt; B -0.0009943199 1.0000000000 -0.03771143 -0.04160253 #&gt; C 0.6635631226 -0.0377114274 1.00000000 -0.39843597 #&gt; D -0.6915520161 -0.0416025327 -0.39843597 1.00000000 correlation The relationship two vectors have to each other. If you sample two sets of numbers independently, they will have a correlation close to 0 (on average). If one number perfectly predicts the other, the correlation is 1 if one gets bigger as the other gets bigger and -1 if one gets smaller as the other gets smaller. Figure 8: Different Correlations (n = 100) covariance matrix Parameters showing how a set of vectors vary and are correlated. The covariance matrix is related to the correlation matrix, but also incorporates information about the standard deviations of all the variables. data &lt;- faux::rnorm_multi( n = 100, mu = 0, sd = c(A = 1, B = 2, C = 3), r = 0.5, empirical = TRUE ) cor(data) # correlation matrix #&gt; A B C #&gt; A 1.0 0.5 0.5 #&gt; B 0.5 1.0 0.5 #&gt; C 0.5 0.5 1.0 cov(data) # covariance matrix #&gt; A B C #&gt; A 1.0 1 1.5 #&gt; B 1.0 4 3.0 #&gt; C 1.5 3 9.0 The matrix of the products of the standard deviations is called “sigma.” If you multiply this by the correlation matrix, you get the covariance matrix. # multiply SDs A B C sigma &lt;- matrix(c(1*1, 1*2, 1*3, # A 2*1, 2*2, 2*3, # B 3*1, 3*2, 3*3), # C nrow = 3) sigma * cor(data) #&gt; A B C #&gt; A 1.0 1 1.5 #&gt; B 1.0 4 3.0 #&gt; C 1.5 3 9.0 CRAN The Comprehensive R Archive Network: a network of ftp and web servers around the world that store identical, up-to-date, versions of code and documentation for R. Packages that you download from CRAN have been checked to make sure they won’t harm your computer. You can learn more about CRAN at https://cran.r-project.org/. Cronbach’s alpha A measure used to assess the internal consistency of scale items If a scale is a reliable measure of a concept, then the items of the scale should consistently measure that concept. A scale where all the items perfectly measure the same concept will have a Cronbach’s alpha close to 1.0, basically meaning that all the items are nearly perfectly correlated. A scale where each item measures a totally different concept will have a Cronbach’s alpha close to 0.0, meaning that each item is uncorrelated with the others. Remember that internal reliability is not the same as external reliability. A scale can have a very high Cronbach’s alpha, meaning it measures something well, but that thing may not be what you meant to measure. We can use the function psych::alpha() to calculate Cronbach’s alpha. # read in data from the 3 domains of disgust scale disgust &lt;- readr::read_csv(&quot;https://psyteachr.github.io/msc-data-skills/data/disgust.csv&quot;) # select just the items that measure pathogen disgust pathogen_alpha &lt;- disgust %&gt;% select(pathogen1:pathogen7) %&gt;% psych::alpha() You often just want to report the raw or standard alpha. pathogen_alpha$total$raw_alpha #&gt; [1] 0.7379495 pathogen_alpha$total$std.alpha #&gt; [1] 0.7441191 The item.stats section gives you some descriptive statistics about each item (see ?psych::alpha for more info). pathogen_alpha$item.stats #&gt; n raw.r std.r r.cor r.drop mean sd #&gt; pathogen1 19668 0.6035673 0.6264342 0.5293053 0.4530070 4.443156 1.457303 #&gt; pathogen2 19683 0.6371098 0.6287978 0.5371302 0.4610671 3.254026 1.745723 #&gt; pathogen3 19687 0.6489288 0.6599706 0.5842526 0.4917248 3.171941 1.616815 #&gt; pathogen4 19683 0.6217909 0.6168016 0.5156972 0.4397615 3.657573 1.755883 #&gt; pathogen5 19678 0.6384423 0.6657726 0.5920388 0.4997309 4.282397 1.435962 #&gt; pathogen6 19655 0.6120328 0.5923052 0.4785793 0.4119616 3.808751 1.878335 #&gt; pathogen7 19692 0.6331624 0.6061906 0.5020210 0.4326954 3.493500 1.930726 You can look at the alpha.drop section to see what the alpha would be if you dropped an item. If we add an item from the moral disgust scale, you can see that the alpha increases if you drop it. mixed_alpha &lt;- disgust %&gt;% select(pathogen1:pathogen7, moral1) %&gt;% psych::alpha() select(mixed_alpha$alpha.drop, raw_alpha, std.alpha) #&gt; raw_alpha std.alpha #&gt; pathogen1 0.6776276 0.6873220 #&gt; pathogen2 0.6770689 0.6903431 #&gt; pathogen3 0.6693926 0.6799724 #&gt; pathogen4 0.6787991 0.6911267 #&gt; pathogen5 0.6704759 0.6776676 #&gt; pathogen6 0.6860804 0.6980331 #&gt; pathogen7 0.6823258 0.6950028 #&gt; moral1 0.7379495 0.7441191 CSS Cascading Style Sheet: A system for controlling the visual presentation of HTML in web pages. R Markdown scripts are often knit to HTML. Therefore, you can also include HTML (a way to semantically tag information) and CSS in your scripts. Here is an example of some simple CSS (in the style tag) and HTML. &lt;style&gt; h3 { color: red; } .ferret { width: 200px; height: 150px; } &lt;/style&gt; &lt;h3&gt;Red Title&lt;/h3&gt; &lt;img src=&quot;images/darwin.jpg&quot; title=&quot;The cutest ferret&quot; class=&quot;ferret&quot;&gt; Resources W3Schools Learn CSS Academic Webpages CSV Comma-separated variable: a file type for representing data where each variable is separated from the next by a comma. "],["d.html", "D data frame data type data wrangling default value dependent variable descriptive deviation score directory discrete distribution double brackets double", " D data frame A container data type for storing tabular data. data.frame( id = 1:5, name = c(&quot;Lisa&quot;, &quot;Phil&quot;, &quot;Helena&quot;, &quot;Rachel&quot;, &quot;Jack&quot;) ) #&gt; id name #&gt; 1 1 Lisa #&gt; 2 2 Phil #&gt; 3 3 Helena #&gt; 4 4 Rachel #&gt; 5 5 Jack data type The kind of data represented by an object. integer (whole numbers like 1L, -10L, 3000L) double (numbers like -0.223, 10.324, 1e4) character (letters or words like “I love R”) logical (TRUE or FALSE) complex (numbers with real and imaginary parts like 2i) Integers and doubles are both numeric. If you want to know what data type a variable is, use the function typeof. typeof(10) #&gt; [1] &quot;double&quot; typeof(&quot;10&quot;) #&gt; [1] &quot;character&quot; typeof(10L) #&gt; [1] &quot;integer&quot; typeof(10 == 10) #&gt; [1] &quot;logical&quot; typeof(10i) #&gt; [1] &quot;complex&quot; data wrangling The process of preparing data for visualisation and statistical analysis. default value A value that a function uses for an argument if it is skipped. For example, mean() has a default value of FALSE for the argument na.rm (don’t ignore NA values). x &lt;- c(1,2,3,NA) mean(x) #&gt; [1] NA So if you leave that argument out, it’s the same as setting it to FALSE. mean(x, na.rm = FALSE) #&gt; [1] NA And you have to explicitly set it if you want it to be different. mean(x, na.rm = TRUE) #&gt; [1] 2 If an argument does not have a default value, you can’t omit it. In the example below, there is no default value for n. x = rnorm() #&gt; Error in rnorm(): argument &quot;n&quot; is missing, with no default dependent variable The target variable that is being analyzed, whose value is assumed to depend on other variables. You are generally interested in how other variables you have measured impact the dependent variable. For example, if you are testing the effect of stress on anxiety, stress would be your independent variable and anxiety would be the dependent variable. The terms independent/dependent variable are typically used in an experimental context. In the context of regression, the dependent variable is often referred to as the response variable. descriptive Statistics that describe an aspect of data (e.g., mean, median, mode, variance, range) Contrast with inferential statistics. deviation score A score minus the mean tibble( score = 8:12 ) %&gt;% mutate(mean = mean(score), deviation_score = score - mean) #&gt; # A tibble: 5 x 3 #&gt; score mean deviation_score #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 8 10 -2 #&gt; 2 9 10 -1 #&gt; 3 10 10 0 #&gt; 4 11 10 1 #&gt; 5 12 10 2 directory A collection or “folder” of files on a computer. In a file path, each directory is separated by forward slashes, e.g., “dir1/dir2/file.Rmd.” Sometimes you need to check if a directory exists and/or make a new directory. For example, a script may save images in a directory called “images” that is in the same directory as the script (so you can use the relative path). Below is code for checking whether that directory exists and making it if it doesn’t. path &lt;- &quot;images&quot; if (!dir.exists(path)) { dir.create(path) } discrete Data that can only take certain values, such as integers. Discrete data are not continuous, so it doesn’t make sense to have a value that is partway between two values. For example, the number of texts you send per day is discrete; you can’t send 12.5 texts. Discrete data can be ordinal or nominal. distribution A way to describe the shape of data normal distribution binomial distribution Poisson distribution uniform distribution double brackets Two pairs of square brackets used to select a single item from a container like a list, data frame, or matrix (e.g., data[[1]]). data &lt;- data.frame( id = 1:3, x = c(1.4, 2.3, 8.2) ) # double brackets return the id column as a vector data[[&quot;id&quot;]] #&gt; [1] 1 2 3 See brackets for an explanation of the difference between single and double brackets. double A data type representing a real decimal number. Examples of doubles are 1, 1.0, -0.01, or 1e4. "],["e.html", "E effect code effect size effect element ellipsis environment error term escape extension extract operator", " E effect code A coding scheme for categorical variables that contrasts each group mean with the mean of all the group means. Also referred to as contrast coding. effect size The difference between the effect in your data and the null effect (usually a chance value) effect Some measure of your data, such as the mean value, or the number of standard deviations the mean differs from a chance value. element One item in a vector. For example, the built-in vector LETTERS contains 26 elements: the uppercase latin letters A through Z. You can select an element from a vector by putting its index in square brackets. # get the tenth upppercase letter LETTERS[10] #&gt; [1] &quot;J&quot; ellipsis Three dots (…) representing further unspecified arguments to a function. When you look up the help for a function, you often see one of the arguments is .... This means that you can supply your own argument names and values here. For example, the help page for dplyr::mutate() shows a usage of mutate(.data, ...), which means that the first argument is called .data and is the data table you want to mutate, and the second argument is ..., which means that you can add as many new arguments as you want and each one will create a new column with the argument name and value. # create a data frame with letters and numbers df &lt;- data.frame( number = 1:5, letter = LETTERS[1:5] ) # the mutate function lets you add custom arguments # like lower and plus_10 mutate( .data = df, lower = tolower(letter), plus_10 = number + 10 ) #&gt; number letter lower plus_10 #&gt; 1 1 A a 11 #&gt; 2 2 B b 12 #&gt; 3 3 C c 13 #&gt; 4 4 D d 14 #&gt; 5 5 E e 15 environment A data structure that contains R objects such as variables and functions The Environment pane defaults to showing the contents of the Global Environment. This is where objects defined in the console or interactively running scripts are stored. You can also use the code ls() to list all objects. When you restart R, the global environment should clear. If it doesn’t, go to Global Options... under the Tools menu (⌘,), and uncheck the box that says Restore .RData into workspace at startup. If you keep things around in your workspace, things will get messy, and unexpected things will happen. You should always start with a clear workspace. This also means that you never want to save your workspace when you exit, so set this to Never. The only thing you want to save are your scripts. You can also use the code rm(list = ls()) or click on the broom icon in the Environment pane to clear the global environment without restarting R. When you knit an R markdown file, this happens in a new environment, so if any of your code relies on objects you created outside your script, that code will run interactively in R Studio, but will fail when you knit because the objects in the gloabl environment are not available in the knitting environment. If you start writing your own functions, you need to understand a little about scope and how the environment inside a function is not the same as the global environment. The Environments chapter in Advanced R is a good resource for advanced understanding. error term The term in a model that represents the difference between the actual and predicted values escape Include special characters like \" inside of a string by prefacing them with a backslash. str &lt;- &quot;This prints a \\&quot;quote\\&quot;&quot; This prints a “quote” extension The end part of a file name that tells you what type of file it is (e.g., .R or .Rmd). Common file types and their extensions File type extension R script .R R Markdown .Rmd Comma-separated variable .csv Plain text .txt Web file .html Word document .doc, .docx PDF .pdf extract operator A symbol used to get values from a container object, such as [, [[, or $ You can extract values from a vector by index or name using [ and [[. my_vector &lt;- c(A = &quot;first&quot;, B = &quot;second&quot;) my_vector[1] # by index, retains name #&gt; A #&gt; &quot;first&quot; my_vector[[1]] # by index, removes name #&gt; [1] &quot;first&quot; my_vector[&quot;B&quot;] # by name, retains name #&gt; B #&gt; &quot;second&quot; my_vector[[&quot;B&quot;]] # by name, removes name #&gt; [1] &quot;second&quot; You can extract values from a list by index or name using [ and [[ and by name using $. my_list &lt;- list( A = &quot;First item&quot;, B = 2 ) my_list[1] # by index, returns a (named) list #&gt; $A #&gt; [1] &quot;First item&quot; my_list[[1]] # by index, returns an (unnamed) vector #&gt; [1] &quot;First item&quot; my_list[&quot;B&quot;] # by name, returns a (named) list #&gt; $B #&gt; [1] 2 my_list[[&quot;B&quot;]] # by name, returns an (unnamed) vector #&gt; [1] 2 my_list$A # by name, returns an (unnamed) vector #&gt; [1] &quot;First item&quot; "],["f.html", "F factor factor (data type) factor (experimental) false negative false positive filtering joins fitted value fixed effect fixed factor full_join function", " F factor A data type where a specific set of values are stored with labels; An explanatory variable manipulated by the experimenter factor (data type) A data type where a specific set of values are stored with labels In tables, you can store strings as characters or factors. data &lt;- tibble( chr = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), fctr = factor(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) ) If you print a character vector, it will have quotes around each values, while a factor vector will show the Levels after. data$chr #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; data$fctr #&gt; [1] A B C #&gt; Levels: A B C In a tibble, these types will have “” or “” under the column header. data #&gt; # A tibble: 3 x 2 #&gt; chr fctr #&gt; &lt;chr&gt; &lt;fct&gt; #&gt; 1 A A #&gt; 2 B B #&gt; 3 C C You can convert between characters and factors like this: as.character(data$fctr) #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; # set the levels to the order you want factor(data$chr, levels = c(&quot;C&quot;, &quot;B&quot;, &quot;A&quot;)) #&gt; [1] A B C #&gt; Levels: C B A Resources Factors in R for Data Science factor (experimental) An explanatory variable manipulated by the experimenter For example, imagine an experiment where you test half of subjects in a dark room with easy, medium, and hard tasks, and the other half in a light room with easy and hard tasks. This experiment has two factors: room darkness and task difficulty. The factor of room darkness is between subjects and has two levels: dark and light. The factor of task difficulty is within subjects has three levels: easy, medium, and hard. See independent variable false negative When a test concludes there is no effect when there really is an effect Also called a type II error, but we prefer the more descriptive “false negative.” See also false positive and beta. false positive When a test concludes there is an effect when there really is no effect Also called a type I error, but we prefer the more descriptive “false positive.” See also false negative and alpha (stats). filtering joins Joins that act like the dplyr::filter() function in that they remove rows from the data in one table based on the values in another table. The result of a filtering join will only contain rows from the left table and have the same number or fewer rows than the left table. anti_join semi_join fitted value The value of the response variable predicted by the model given certain values for any predictor variables. If you have a model \\[Y_i = \\beta_0 + \\beta_1 X_i + e_i\\] then the fitted value for observation \\(i\\) equals \\(\\beta_0 + \\beta_1 X_i\\); that is, the model’s prediction for a residual (\\(e_i\\)) of zero. fixed effect An effect assumed to be identical over all sampling units. In the standard regression model \\[Y_i = \\beta_0 + \\beta_1 X_i + e_i\\] the parameters \\(\\beta_0\\) (the intercept) and \\(\\beta_1\\) (the slope) are assumed to be constant across all sampling units (e.g. subjects). These are contrasted with random effects, which are effects that differ across the units. In a mixed effects model, you can get a table of just the fixed effects with the code below: model &lt;- afex::lmer( rating ~ rater_age * face_age + # fixed effects (1 | rater_id) + (1 | face_id), # random effects data = faux::fr4 ) broom.mixed::tidy(model, effects = &quot;fixed&quot;) #&gt; # A tibble: 4 x 7 #&gt; effect term estimate std.error statistic df p.value #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 fixed (Intercept) 3.81 0.882 4.32 92.6 0.0000387 #&gt; 2 fixed rater_age 0.00415 0.0251 0.165 71.1 0.869 #&gt; 3 fixed face_age -0.0353 0.0253 -1.40 92.2 0.165 #&gt; 4 fixed rater_age:face_age -0.000382 0.000617 -0.619 712. 0.536 fixed factor A factor whose levels are assumed to represent all the levels of interest in a population; its levels would remain fixed across replications of the study. For example, if you were studying the nations making up the United Kingdom, you would have a factor with the levels England, Northern Ireland, Scotland, and Wales. If you would replicate a study, you would include these exact same levels. These four levels represent all the nations comprising the union, and there usually would be no interest in generalizing beyond the data to other (hypothetical) nations. Fixed factors are usually contrasted with random factors, whose levels usually are assumed to be the result of (quasi-)random sampling. full_join A mutating join that lets you join up rows in two tables while keeping all of the information from both tables Figure 9: Full Join X &lt;- tibble( id = 1:5, x = LETTERS[1:5] ) Y &lt;- tibble( id = 2:6, y = LETTERS[22:26] ) Table X Table Y id x 1 A 2 B 3 C 4 D 5 E id y 2 V 3 W 4 X 5 Y 6 Z If there is no matching data in the other table for a row, the values are set to NA. # a columns come first data &lt;- full_join(a, b, by = &quot;id&quot;) id x.x y x.y 1 A TRUE NA 2 B TRUE NA 3 C FALSE NA 4 NA NA D 5 NA NA E 6 NA NA F Order is not important for full joins, but does change the order of columns in the resulting table. # b columns come first data &lt;- full_join(b, a, by = &quot;id&quot;) x.x id x.y y D 4 NA NA E 5 NA NA F 6 NA NA NA 1 A TRUE NA 2 B TRUE NA 3 C FALSE See joins for other types of joins and further resources. function A named section of code that can be reused. For example, sd is a function that returns the standard deviation of the vector of numbers that you provide as the input argument. Functions are set up like this: function_name(argument1 = a1, argument2 = a2). The arguments in parentheses can be named (like, x = c(1,3,5,8)) or you can skip the names if you put them in the exact same order that they’re defined in the function. You can check this by typing ?sd (or whatever function name you’re looking up) into the console and the Help pane will show you the default order under Usage. Figure 10: Function help "],["g.html", "G general linear model generalizability geom git github glm global environment", " G general linear model A mathematical model comparing how one or more independent variables affect a continuous dependent variable The GLM is a general mathematical framework for expressing relationships among variables that can express or test linear relationships between a numerical dependent variable and any combination of categorical or continuous independent variables. generalizability A term referring to the degree to which findings can be readily applied to situations beyond the particular context in which the data were collected. In the ideal case, we want our findings to be as generalizable as possible. However, when collecting data, we face limitations in the kinds of people, stimuli, and situations we are able to observe. Findings from a study are not generalizable if they do not apply beyond the context in which they are collected. Subjects, stimuli, tasks, and situations are all factors to consider when assessing the generalizability of a study. geom The geometric style in which data are displayed, such as boxplot, density, or histogram. In ggplot2, the geoms control how your data are visualised. You can start with the same base plot… gg &lt;- ggplot(mtcars, aes(as.factor(gear), hp)) + labs(x = &quot;Number of gears&quot;, y = &quot;Horsepower&quot;) …and use different geoms to visualise it: gg + geom_boxplot() Figure 11: Visualisation using geom_boxplot gg + geom_violin() Figure 12: Visualisation using geom_violin gg + stat_summary(geom = &quot;pointrange&quot;) Figure 13: Visualisation using pointrange gg + stat_summary(geom = &quot;crossbar&quot;) Figure 14: Visualisation using crossbar git One type of version control software. Set up git and github with RStudio. github A cloud-based service for storing and sharing your version controlled files. Set up git and github with RStudio. glm A mathematical model comparing how one or more independent variables affect a continuous dependent variable See general linear model global environment The interactive workspace where your script runs When you create a variable, it is usually stored in the global environment. You can view this in the environment tab of the top right pane of RStudio. If you create a variable inside of a function, it is usually not accessible outside of that function and you won’t see it in the global environment tab. You don’t need to know much about environments to use R until you start developing packages; they are covered in Advanced R. "],["h.html", "H hierarchical model HTML hypothesis", " H hierarchical model A type of regression model that involves estimating both fixed effects and random effects. See linear mixed effects model. HTML Hyper-Text Markup Language: A system for semantically tagging structure and information on web pages. R Markdown scripts are often knit to HTML. Therefore, you can also include HTML and CSS (a way to control visual style) in your scripts. Here is an example of some simple HTML. &lt;h1&gt;My Title&lt;/h1&gt; &lt;p&gt;A paragraph of stuff...&lt;/p&gt; &lt;ul&gt; &lt;li&gt;List item&lt;/li&gt; &lt;li&gt;Another list item&lt;/li&gt; &lt;/ul&gt; &lt;img src=&quot;images/darwin.jpg&quot; title=&quot;The cutest ferret&quot;&gt; Resources W3Schools Learn HTML Academic Webpages hypothesis A proposed explanation made on the basis of limited evidence as a starting point for further investigation. "],["i.html", "I IDE %in% independent variable index inferential inner-join integer intercept iteration", " I IDE Integrated Development Environment: a program that serves as a text editor, file manager, and provides functions to help you read and write code. RStudio is an IDE for R. %in% The match operator, a binary operator that returns a logical vector indicating if there is a match or not for its left operand. independent variable A variable whose value is assumed to influence the value of a dependent variable. This term is often used in an experimental context. In a regression context, this is equivalent in meaning to predictor variable. index The number that represents an element’s location in a vector. For example, the index of the letter E in the vector LETTERS is 5. This can also refer to the main page of a website. For example, the address for the main page of the glossary is technically https://psyteachr.github.io/glossary/index.html (but https://psyteachr.github.io/glossary/ invisibly directs you to the index page). inferential Statistics that allow you to make predictions about or comparisons between data (e.g., t-value, F-value, rho) Contrast with descriptive statistics. inner-join A mutating join that returns all the rows that have a match in the other table. Figure 15: Inner Join X &lt;- tibble( id = 1:5, x = LETTERS[1:5] ) Y &lt;- tibble( id = 2:6, y = LETTERS[22:26] ) Table X Table Y id x 1 A 2 B 3 C 4 D 5 E id y 2 V 3 W 4 X 5 Y 6 Z # a columns come first data &lt;- inner_join(a, b, by = &quot;id&quot;) id x.x y x.y Order is not important for inner joins, but does change the order of columns in the resulting table. # b columns come first data &lt;- inner_join(b, a, by = &quot;id&quot;) x.x id x.y y See joins for other types of joins and further resources. integer A data type representing whole numbers. In R, you specify that a number is an integer by adding an L at the end, like 1L, -36L, or 100L. intercept Also referred to as y-intercept, this is a constant corresponding to the value of the \\(y\\) variable (in a regression context, the response variable) when all predictor variables are set to zero. iteration Repeating a process or function "],["j.html", "J joins", " J joins Ways to combine data from two tables binding joins bind_rows bind_cols filtering joins: anti_join semi_join mutating joins: left_join right_join inner_join full_join Further Resources Data Relations in Data Skills for Reproducible Science Relational Data in R for Data Science Cheatsheet for dplyr join functions "],["k.html", "K knit", " K knit To create an HTML, PDF, or Word document from an R Markdown (Rmd) document You can knit your Rmd file by clicking on the Knit button at the top of the source pane or typing knitr::knit(\"file.Rmd\", \"file.html\") in the console pane. In the context of R Markdown files, knit, render and compile tend to be used interchangeably. "],["l.html", "L left_join level Likert Linear mixed-effects model list logical long", " L left_join A mutating join that keeps all the data from the first (left) table and joins anything that matches from the second (right) table. Figure 16: Left Join X &lt;- tibble( id = 1:5, x = LETTERS[1:5] ) Y &lt;- tibble( id = 2:6, y = LETTERS[22:26] ) Table X Table Y id x 1 A 2 B 3 C 4 D 5 E id y 2 V 3 W 4 X 5 Y 6 Z If there is no matching data in the right table for a row, the values are set to NA. # X is the left table data &lt;- left_join(X, Y, by = &quot;id&quot;) id x y 1 A NA 2 B V 3 C W 4 D X 5 E Y Order is important for left joins. # Y is the left table data &lt;- left_join(Y, X, by = &quot;id&quot;) id y x 2 V B 3 W C 4 X D 5 Y E 6 Z NA See joins for other types of joins and further resources. level The set of valid values for a factor Setting the levels for a factor can be helpful to make sure they display and plot in the intended order. # levels in the right order day_levels &lt;- c(&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;) # repeat each day 1:7 times days &lt;- rep(day_levels, 1:7) # make into factors with and without levels without_levels &lt;- factor(days) with_levels &lt;- factor(days, levels = day_levels) ggplot() + geom_bar(aes(x = without_levels)) Figure 17: Without setting levels, categories display in alphabetical order. ggplot() + geom_bar(aes(x = with_levels)) Figure 18: With setting levels, categories display in the level order Likert A rating scale with a small number of discrete points in order An example of a Likert scale is the following: Question 1 = Much less than average 2 = Less than average 3 = Average 4 = More than average 5 = Much more than average I like R I like stats The points on Likert scales are ordinal, but not necessarily continuous. That is, you can assume 3 is higher than 2, but the difference between 2 and 3 isn’t always the same as the difference between 1 and 2. Therefore, think carefully before averaging Likert values, since the average of 2 and 4 is not necessarily equal to 3. Linear mixed-effects model A type of regression model that involves estimating both fixed effects and random effects. Most conventional regression models only estimate parameters associated with fixed effects and residual error. Mixed-effects models additionally estimate random effects parameters that capture variability associated with sampling units. In psychology, these sampling units are usually human participants or stimulus items. Linear mixed-effects models are often called multi-level models or hierarchical models; these terms are roughly interchangeable. Linear mixed-effects models (LMEMs) are still linear models in the sense that they model a response variable in terms of a linear combination of predictor variables whose values are weighted by parameter estimates. Because there is no closed form solution to finding the optimal parameter estimates, their values are typically estimated through an iterative procedure that searches the space of possible values for the optimum. The function lmer() from the R package lme4 is often used to estimate mixed-effects models. The brms package in R allows Bayesian estimation of mixed-effects models. list A container data type that allows items with different data types to be grouped together. Each item in a list can be any type of R object, but is usually a vector or another list. list( integers = 1:10, strings = LETTERS, another_list = list(1, &quot;A&quot;, TRUE), object = rnorm ) #&gt; $integers #&gt; [1] 1 2 3 4 5 6 7 8 9 10 #&gt; #&gt; $strings #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; #&gt; [21] &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; #&gt; #&gt; $another_list #&gt; $another_list[[1]] #&gt; [1] 1 #&gt; #&gt; $another_list[[2]] #&gt; [1] &quot;A&quot; #&gt; #&gt; $another_list[[3]] #&gt; [1] TRUE #&gt; #&gt; #&gt; $object #&gt; function (n, mean = 0, sd = 1) #&gt; .Call(C_rnorm, n, mean, sd) #&gt; &lt;bytecode: 0x7fd613a5c410&gt; #&gt; &lt;environment: namespace:stats&gt; logical A data type representing TRUE or FALSE values. true_logical_values &lt;- list( full = TRUE, abbreviated = T, integer = as.logical(1), equation = &quot;A&quot; == &quot;A&quot; ) str(true_logical_values) #&gt; List of 4 #&gt; $ full : logi TRUE #&gt; $ abbreviated: logi TRUE #&gt; $ integer : logi TRUE #&gt; $ equation : logi TRUE false_logical_values &lt;- list( full = FALSE, abbreviated = F, integer = as.logical(0), equation = &quot;A&quot; == &quot;B&quot; ) str(false_logical_values) #&gt; List of 4 #&gt; $ full : logi FALSE #&gt; $ abbreviated: logi FALSE #&gt; $ integer : logi FALSE #&gt; $ equation : logi FALSE long Data where each observation is on a separate row Table 1: Long data id item value A Q1 1 B Q1 4 A Q2 2 B Q2 5 A Q3 3 B Q3 6 Contrast with wide data. "],["m.html", "M markdown match operator matrix mean mixed design multilevel model multilevel multivariate mutating joins", " M markdown A way to specify formatting, such as headers, paragraphs, lists, bolding, and links. See R Markdown for more infomation on the R-specific version. match operator A binary operator (%in%) that returns a logical vector indicating if there is a match or not for its left operand. # check if a single value is in a vector &quot;West Dakota&quot; %in% state.name #&gt; [1] FALSE # check if each item in the lefthand vector is in the righthand vector c(&quot;A&quot;, &quot;B&quot;, &quot;1&quot;) %in% LETTERS #&gt; [1] TRUE TRUE FALSE pangram &lt;- &quot;the quick brown fox jumps over the lazy dog&quot; pangram_chars &lt;- strsplit(pangram, &quot;&quot;)[[1]] letters %in% pangram_chars #&gt; [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #&gt; [17] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE matrix A container data type consisting of numbers arranged into a fixed number of rows and columns You can use the matrix() function to set up a vector of numbers as a matrix with a specified number of rows of columns. # a 4x4 matrix matrix(data = 1:16, nrow = 4) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 5 9 13 #&gt; [2,] 2 6 10 14 #&gt; [3,] 3 7 11 15 #&gt; [4,] 4 8 12 16 Set byrow = TRUE to assign the vector across rows rather than down columns. matrix(data = 1:16, nrow = 4, byrow = TRUE) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 2 3 4 #&gt; [2,] 5 6 7 8 #&gt; [3,] 9 10 11 12 #&gt; [4,] 13 14 15 16 mean A descriptive statistic that measures the average value of a set of numbers. x &lt;- c(1,2,3,4,5) mean(x) #&gt; [1] 3 mixed design An experimental design that has both within-subject and between-subject factors. For example, imagine an experiment where you test half of subjects in a dark room with easy, medium, and hard tasks, and the other half in a light room with easy and hard tasks. This experiment has two factors: room darkness and task difficulty. The factor of room darkness is between subjects and has two levels: dark and light. The factor of task difficulty is within subjects has three levels: easy, medium, and hard. Because this experiment has both within- and between-subject factors, it is described as having a mixed design. multilevel model A type of regression model that involves estimating both fixed effects and random effects. See linear mixed effects model. multilevel (or multi-level) Relating to datasets where there are multiple observations taken on the same variable on the same sampling units (usually subjects or stimuli). A multilevel dataset is one where there are repeated measurements on the same subjects on the same variable. If you have multiple measurements on the same subjects but on different variables, with no more than one measurement per subject per variable, you have multivariate data, not multilevel data. It is called “multilevel” because different measurements might be taken at different levels. For example, in a simple reaction time study, you may measure how quickly someone presses a button in response to a flashing light. You can have measurements at the level of the individual trial (the intensity of the flash) as well as measurements at the level of the individual subject (the subject’s age in years). A multilevel model is one that can account for the variance introduced at the various levels. See also repeated measures. multivariate Having multiple measurements on the same subjects but on different variables, with no more than one measurement per subject per variable. Table 2: Multivariate data with 3 scores on different tasks per person id stroop memory iat S1 14 78 7 S2 12 72 5 S3 10 76 5 S4 10 76 4 S5 13 81 6 Contrast with univariate. mutating joins Joins that act like the dplyr::mutate() function in that they add new columns to one table based on values in another table. left_join right_join inner_join full_join "],["n.html", "N NA NHST nominal normal distribution null effect numeric", " N NA A missing value that is “Not Available” You can use NA to represent missing values in a vector. Use the function is.na() to check if values are missing. values &lt;- c(1,4,NA,3,4) is.na(values) #&gt; [1] FALSE FALSE TRUE FALSE FALSE If the results of a calculation like mean() or sd() is NA, this usually means that you have some missing values in your vector. You can remove NA values using na.rm = TRUE in many functions. mean(values) #&gt; [1] NA mean(values, na.rm = TRUE) #&gt; [1] 3 Dealing with missing values when calculating correlations is a little trickier. dat &lt;- tribble( ~x, ~y, ~z, 1, 3, NA, # x-y included when p.c.o 2, 1, 4, 3, 5, 3, 4, 1, 2, NA, 5, 1 # y-z included when p.c.o ) # uses only rows 2:4 for all correlations cor(dat, use = &quot;complete.obs&quot;) #&gt; x y z #&gt; x 1 0 -1 #&gt; y 0 1 0 #&gt; z -1 0 1 # uses rows 1:4 for x-y, 2:5 for y-z, and 2:4 for x-z cor(dat, use = &quot;pairwise.complete.obs&quot;) #&gt; x y z #&gt; x 1.00000 -0.1348400 -1.0000000 #&gt; y -0.13484 1.0000000 -0.4472136 #&gt; z -1.00000 -0.4472136 1.0000000 You can filter a table down to only rows with no NA values using na.omit(). complete_dat &lt;- na.omit(dat) x y z 2 1 4 3 5 3 4 1 2 NHST Null Hypothesis Signficance Testing nominal Categorical variables that don’t have an inherent order, such as types of animal. normal distribution A symmetric distribution of data where values near the centre are most probable. A normal distribution is characterised by its mean and standard deviation. You can sample numbers from a simulated normal distribution with the function rnorm(). # sample 1 million numbers from a normal distribution with # a mean of 0 and a standard deviation of 1 x &lt;- rnorm(1000000, mean = 0, sd = 1) Figure 19: Normal Distribution About 68% of the values are within 1 SD of the mean. # proportion between -1 and 1 mean(x &gt; -1 &amp; x &lt; 1) #&gt; [1] 0.682617 About 95% of the values are within 2 SDs of the mean. # proportion between -2 and 2 mean(x &gt; -2 &amp; x &lt; 2) #&gt; [1] 0.954465 null effect An outcome that does not show an otherwise expected effect. A null effect could be a difference of 0 between two groups, or a chance value, such as 50% is a two-alternative forced choice task. numeric A data type representing a real decimal number or integer. The integer and double data types are numeric. You can check if a variable is numeric using the function is.numeric and you can convert a variable to its numeric representation using the function as.numeric. is.numeric(2.4) #&gt; [1] TRUE is.numeric(2L) #&gt; [1] TRUE # complex numbers are not numeric is.numeric(2i) #&gt; [1] FALSE is.numeric(&quot;A&quot;) #&gt; [1] FALSE # numbers represented as strings are not numeric is.numeric(&quot;3&quot;) #&gt; [1] FALSE as.numeric(2.4) #&gt; [1] 2.4 as.numeric(2L) #&gt; [1] 2 # the imaginary part of complex numbers is discarded when converting to numeric as.numeric(3+2i) #&gt; Warning: imaginary parts discarded in coercion #&gt; [1] 3 # strings that do not represent numbers are converted to NA as.numeric(&quot;A&quot;) #&gt; Warning: NAs introduced by coercion #&gt; [1] NA # numbers represented as strings can be convertd to their numeric version as.numeric(&quot;3&quot;) #&gt; [1] 3 "],["o.html", "O object observation one-tailed operator ordinal outer join outlier", " O object A word that identifies and stores the value of some data for later use. Sometimes objects are also called variables. An object in R: contains only letters, numbers, full stops, and underscores starts with a letter or a full stop and a letter distinguishes uppercase and lowercase letters (rickastley is not the same as RickAstley) The following are valid and different objects: songdata SongData song_data song.data .song.data never_gonna_give_you_up_never_gonna_let_you_down The following are not valid objects: _song_data 1song .1song song data song-data observation All of the data about a single trial or question. In a tidy dataset, each row contains only one observation. Each row contains 3 observations: library(dplyr) library(tidyr) untidy &lt;- data.frame( id = 1:5, score_1 = sample(1:7, 5), score_2 = sample(1:7, 5), score_3 = sample(1:7, 5), rt_1 = rnorm(5, 800, 100) %&gt;% round(), rt_2 = rnorm(5, 800, 100) %&gt;% round(), rt_3 = rnorm(5, 800, 100) %&gt;% round() ) id score_1 score_2 score_3 rt_1 rt_2 rt_3 1 6 4 2 679 923 908 2 7 5 6 884 821 701 3 5 1 7 696 951 1011 4 4 3 5 774 751 805 5 3 6 3 814 1047 636 Now each row contains 1 observation: tidy &lt;- untidy %&gt;% gather(var, val, score_1:rt_3) %&gt;% separate(var, c(&quot;var&quot;, &quot;trial&quot;)) %&gt;% spread(var, val) id trial rt score 1 1 679 6 1 2 923 4 1 3 908 2 2 1 884 7 2 2 821 5 2 3 701 6 3 1 696 5 3 2 951 1 3 3 1011 7 4 1 774 4 4 2 751 3 4 3 805 5 5 1 814 3 5 2 1047 6 5 3 636 3 one-tailed A statistical test for which the critical region consists of all values of the test statistic greater or less than a given value. See p-value for a comparison of one-tailed and two-tailed tests. operator A symbol that performs a mathematical operation, such as +, -, *, / Arithmetic operators in R Operator Definition Example + Addition: adds two numbers 3+2 = 5 - Subtraction: subtracts the second number from the first (3-2 = 1) * Multiplication: multiplies two numbers 3*2 = 6 / Division: divides the first number by the second 3/2 = 1.5 %% Modulus: returns the remainder after dividing the first number by the second 3%%2 = 1 ^ Exponent: raises the first number to the power of the second 3^2 = 9 Relational operators in R Operator Definition Example == Equal to 1 == 1 or \"A\" == \"A\" != Not equal to 1 != 2 or \"A\" != \"B\" &gt; Greater than 2 &gt; 1 or \"B\" &gt; \"A\" &gt;= Greater than or equal to 2 &gt;= 1 or \"B\" &gt;= \"A\" &lt; Less than 1 &lt; 2 or \"A\" &lt; \"B\" &lt;= Less than or equal to 1 &lt;= 2 or \"A\" &lt;= \"B\" %in% Match operator \"A\" %in% LETTERS Logical operators in R Operator Definition Example &amp; AND (compares each element of vectors) c(T, T, F, F) &amp; c(T, F, T, F) == c(T, F, F, F) | OR (compares each element of vectors) c(T, T, F, F) | c(T, F, T, F) == c(T, T, T, F) &amp;&amp; AND (only compares the first element of vectors) c(T, F) &amp;&amp; c(T, F) == TRUE || OR (only compares the first element of vectors) c(T, F) || c(F, F) == TRUE ! NOT !TRUE == FALSE ordinal Discrete variables that have an inherent order, such as number of legs Ordinal variables are not necessarily continuous. That is, you can assume 3 is higher than 2 on a likert scale, but the difference between 2 and 3 isn’t always the same as the difference between 1 and 2. Therefore, think carefully before averaging ordinal values, since the average of 2 and 4 is not necessarily equal to 3. outer join A mutating join that lets you join up rows in two tables while keeping all of the information from both tables (full_join) The term “outer join” is more commonly used in SQL. See full_join for the R version. outlier A data point that is extremely distant from most of the other data points Outliers can be clear errors (e.g., a value of 1.56 cm for human height), fully random extreme values (e.g., 0.27% of values from a normal distribution are expected to be more than 3 SD from the mean), or reflect potential moderators (e.g., reaction times when paying attention versus being distracted). The unthinking “rule” to label all data points more than 3 SD from the mean as outliers is not considered to be a good way to deal with outliers. The paper below contains useful suggestions. Leys, C., Delacre, M., Mora, Y. L., Lakens, D., &amp; Ley, C. (2019). How to Classify, Detect, and Manage Univariate and Multivariate Outliers, With Emphasis on Pre-Registration. International Review of Social Psychology, 32(1), 5. DOI: 10.5334/irsp.289 "],["p.html", "P p-value package panes parameter path pipe Poisson distribution population parameter population power predictor variable preregistration probability project pseudoreplication", " P p-value The probability of seeing an effect at least as extreme as what you have, if the real effect was the value you are testing against (e.g., a null effect) For example, if you used a binomial test to test against a chance probability of 1/2 (e.g., the probability of heads when flipping a fair coin), then a p-value of 0.37 means that you could expect to see effects at least as extreme as your data (i.e., 55 or more heads or tails) 37% of the time just by chance alone. # test how likely 55 heads (or a more extreme value) # is to result from 100 flips of a fair (prob = 0.5) coin binom.test(55, 100, 0.5) #&gt; #&gt; Exact binomial test #&gt; #&gt; data: 55 and 100 #&gt; number of successes = 55, number of trials = 100, p-value = 0.3682 #&gt; alternative hypothesis: true probability of success is not equal to 0.5 #&gt; 95 percent confidence interval: #&gt; 0.4472802 0.6496798 #&gt; sample estimates: #&gt; probability of success #&gt; 0.55 P-values can be one-tailed or two-tailed. The example above if two-tailed because we didn’t specify a direction and are testing whether there were more or fewer heads than expected by chance with a fair coin. The example below is one-tailed, and indicates that you have an 18% chance of getting 55 or more heads when flipping a fair coin 100 times. # test how likely 55 (or more) heads # is to result from 100 flips of a fair (prob = 0.5) coin binom.test(55, 100, 0.5, alternative = &quot;greater&quot;) #&gt; #&gt; Exact binomial test #&gt; #&gt; data: 55 and 100 #&gt; number of successes = 55, number of trials = 100, p-value = 0.1841 #&gt; alternative hypothesis: true probability of success is greater than 0.5 #&gt; 95 percent confidence interval: #&gt; 0.4628896 1.0000000 #&gt; sample estimates: #&gt; probability of success #&gt; 0.55 You can see that the p-value is half of the two-tailed value; this is true for symmetric distributions like the binomial distribution, but not for all distributions. If you do a one-tailed test using “less,” the p-value is much higher, indicating that you have an 86% chance of getting 55 or fewer heads when flipping a fair coin 100 times. # test how likely 55 (or fewer) heads # is to result from 100 flips of a fair (prob = 0.5) coin binom.test(55, 100, 0.5, alternative = &quot;less&quot;) #&gt; #&gt; Exact binomial test #&gt; #&gt; data: 55 and 100 #&gt; number of successes = 55, number of trials = 100, p-value = 0.8644 #&gt; alternative hypothesis: true probability of success is less than 0.5 #&gt; 95 percent confidence interval: #&gt; 0.0000000 0.6348377 #&gt; sample estimates: #&gt; probability of success #&gt; 0.55 package A group of R functions. Many useful functions are built into R and available by default whenever you start it up. But some of the most powerful things you can do with R require packages of functions that are written by the community. The functions in these packages aren’t available until you install the package (using install.packages(\"package_name\") or clicking Install on the Packages pane; this only needs to be done if the package isn’t already installed). Once that package is installed (kind of like downloading an app to your phone), you can use it in any script by loading that package as a library at the top of your script (e.g., (library(ggplot2)). You can alternatively type the package name and two colons before any function from that package to use it without loading all of its functions into the library (e.g., ggplot2::geom_histogram()). This sort of notation is also used to disambiguate function names if two packages have functions with the same names. panes RStudio is arranged with four window “panes.” By default, the upper left pane is the source pane, where you view and edit source code from files. The bottom left pane is usually the console pane, where you can type in commands and view output messages You can change the location of panes and what tabs are shown under Preferences &gt; Pane Layout. Figure 20: Pane layout parameter A value that describes a distribution, such as the mean or SD path A string representing the location of a file or directory. A file path can be relative to the working directory or absolute. # list all files in the images directory, # use relative path list.files(path = &quot;images/&quot;) # list all files on the Desktop, # use absolute path list.files(path = &quot;/Users/myaccount/Desktop/&quot;) pipe Pipes are a way to order your code in a more readable format. The symbol %&gt;% takes the object created by a function and sends it to the next function. By default, it will be used as the first argument, and most tidyverse functions are optimised for this, but you can also include the result as another argument using . (see the example below). Instead of making a new object for each step: # this makes 4 unnecessary objects data &lt;- rnorm(20) # simulate 20 values t &lt;- t.test(data) # 1-sample t-test p &lt;- t$p.value # extract p-value rounded_p &lt;- round(p, 3) # round to 3 digits paste(&quot;p = &quot;, rounded_p) # format #&gt; [1] &quot;p = 0.363&quot; Or nesting functions: # this is unreadable; never do this paste(&quot;p = &quot;, round(t.test(rnorm(20))$p.value, 3)) #&gt; [1] &quot;p = 0.363&quot; You can pipe the results of each function to the next function: rnorm(20) %&gt;% # simulate 20 values t.test() %&gt;% # 1-sample t-test `[[`(&quot;p.value&quot;) %&gt;% # extract p-value, `[[`(data, &quot;x&quot;) is the same as data[[&quot;x&quot;]] round(3) %&gt;% # round to 3 digits paste(&quot;p = &quot;, .) # format #&gt; [1] &quot;p = 0.363&quot; # use . to represent the previous data if it&#39;s not the first argument See a more detailed example. The symbol | is also called a “pipe” and means “OR” in R, although it has other meanings that are more similar to the %&gt;% pipe in some other programming languages. Poisson distribution A distribution that models independent events happening over a unit of time lambda &lt;- 3 # mean number of events x &lt;- rpois(10000, lambda) Figure 21: Poisson Distribution population parameter A quantity representing a property of a population of interest. In a psychology context, parameters are constants that are assumed to reflect a typical values for some property appearing in some human group to which we want to generalized. For instance, it may reflect an overall reaction time or an overall priming effect, with individual subjects varying from this fixed value. Population parameters are typically unobserved and usually unobservable due to sampling error and measurement error, and are estimated from the values in the sample. The exception is in data simulation, where hypothetical population parameters can be fixed by the researcher. population All members of a group that we wish to generalise our findings to. E.g. all students taking Psychology at the University of Glasgow. We draw our testing sample from the population.. The population of interest can be any group and it is important that you define this in your study when considering the generalisability of your tests and how you will conduct your sampling. If you want to generalise to everyone in the world then that is the population you should sample from. If you want to generalise to everyone taking Psychology at the University of Glasgow then those are the people you should specifically sample from. Remember that populations don’t have to be humans but could refer to all possible variations of a face for example. The key question is who or what do your results generalise to. For an interesting paper on populations, samples and generalisability, see: Simons, D. J., Shoda, Y., &amp; Lindsay, D. S. (2017). Constraints on Generality (COG): A Proposed Addition to All Empirical Papers. Perspectives on Psychological Science, 12(6), 1123–1128. https://doi.org/10.1177/1745691617708630 power The probability of rejecting the null hypothesis when it is false. predictor variable A variable whose value is used (in a model) to predict the value of a response variable. In an experimental context, predictor variables are often referred to as independent variables. preregistration Specifying the methods and analysis of a study before it is run. Resources Center for Open Science The Preregistration Revolution: PNAS / Preprint probability A number between 0 and 1 where 0 indicates impossibility of the event and 1 indicates certainty project A way to organise related files in RStudio. Choose New Project... under the File menu to create a new project in a new folder, organise an existing folder of files as a project, or download a version controlled repository as a project. Figure 22: Start a new project pseudoreplication The process of artificially inflating the number of samples or replicates Pseudoreplications can occur when you take multiple measurements within the same condition. For instance, imagine a study where you randomly assign participants to consume one of two beverages—alcohol or water—before administering a simple response time task where they press a button as fast as possible when a light flashes. You would probably take more than one measurement of response time for each participant; let’s assume that you measured it over 100 trials. You’d have one between-subject factor (beverage) and 100 observations per subject, for say, 20 subjects in each group. One common mistake novices make when analyzing such data is to try to run a t-test. You can’t directly use a conventional t-test when you have pseudoreplications (or multiple stimuli). You must first calculate means for each subject, and then run your analysis on the means, not on the raw data. There are versions of ANOVA that can deal with pseudoreplications, but you are probably better off using a linear-mixed effects model, which can better handle the complex dependency structure. "],["q.html", "Q Q-Q plot quantile", " Q Q-Q plot A scatterplot created by plotting two sets of quantiles against each other, used to check if data come from a specified distribution It is pretty difficult to tell from looking at a density plot if data are distributed in a specific way. We often want to determine if, for example, the residuals of a model are normally distributed. Q-Q plots can help with this. Let’s simulate 25 data points from a normal distribution with a mean of 100 and SD of 10. Since there are not many data points, the resulting plot will be pretty lumpy. The red line is a perfect normal distribution. A &lt;- rnorm(25, 100, 10) ggplot() + geom_density(aes(A)) + geom_function(fun = dnorm, args = list(mean = 100, sd = 10), colour = &quot;red&quot;) Figure 23: Density plot of sample data and the normal distribution it was drawn from A Q-Q plot calculates what quantile each data point is in, and plots that against the theoretical quantiles from the normal distribution. The red line is the theoretically perfect noraml distribution, so you just need to assess if most of the points fall on this line. qplot(sample = A) + geom_qq_line(colour = &quot;red&quot;) Figure 24: Q-Q plot of a small sample from a normal distribution Here’s what it might look like if your data are actually from a uniform distribution. U &lt;- runif(25, 0, 10) qplot(sample = U) + geom_qq_line(colour = &quot;red&quot;) Figure 25: Q-Q plot of a uniform distribution quantile Cutoffs dividing the range of a distribution into continuous intervals with equal probabilities. You can take a sample of numbers on divide them into N equally-sized groups. Let’s use these 12 numbers as an example: x &lt;- c(1, 1, 2, 2, 3, 4, 4, 5, 7, 7, 7, 10) The quantile() function gives you the cutoffs for each quantile from the data. Set the argument probs to seq(0, 1, 1/N) for any N-tile. # median quantile(x, probs = seq(0, 1, 1/2)) #&gt; 0% 50% 100% #&gt; 1 4 10 # tertile quantile(x, probs = seq(0, 1, 1/3)) #&gt; 0% 33.33333% 66.66667% 100% #&gt; 1.000000 2.666667 5.666667 10.000000 # quartile quantile(x, probs = seq(0, 1, 1/4)) #&gt; 0% 25% 50% 75% 100% #&gt; 1 2 4 7 10 dat &lt;- data.frame( x = x ) %&gt;% mutate( `2-tile` = ntile(x, 2), `3-tile` = ntile(x, 3), `4-tile` = ntile(x, 4), `6-tile` = ntile(x, 6) ) x 2-tile 3-tile 4-tile 6-tile 1 1 1 1 1 1 1 1 1 1 2 1 1 1 2 2 1 1 2 2 3 1 2 2 3 4 1 2 2 3 4 2 2 3 4 5 2 2 3 4 7 2 3 3 5 7 2 3 4 5 7 2 3 4 6 10 2 3 4 6 See Q_Q plots. "],["r.html", "R R markdown random effect random factor random seed reactivity relative path render repeated measures replicability reproducibility reproducible research residual error response variable right_join RStudio", " R R markdown The R-specific version of markdown: a way to specify formatting, such as headers, paragraphs, lists, bolding, and links, as well as code blocks and inline code. An R markdown file starts with a YAML header that usually contains the title, author, and output type. --- title: &quot;Analysis Plan Template&quot; author: &quot;School of Psychology, University of Glasgow&quot; output: html_document --- The rest of the file is a mix of markdown and code chunks. Here is an example of two section titles. The first section has an r chunk for loading the packages and the second section has a list of steps. ## Packages used ```{r setup, include = FALSE} # every time you add a new package, include it in this section library(tidyverse) ``` ## Data Processing 1. load in packages 2. load in dataset 3. Wrangle data into appropriate format for analysis and checks. You might want to reshape the data or combine different values to make a new variable. Resources: Introduction to R Markdown R Markdown Cheatsheet R Markdown Reference random effect An effect associated with an individual sampling unit, usually represented by an offset from a fixed effect. Example: If the grand mean response time in a population is 600 milliseconds, that number represents the typical value. The mean response time for an individual subject \\(s\\) can be represented as an offset (deviation) from that value. For example, if subject \\(s\\) has a mean reaction time of 650 ms, that would imply a random effect for that subject of +50 ms. Unlike fixed effects, we expect the underlying random effects to change from experiment to experiment as the sampling units (e.g., subjects) change. In a mixed effects model, you can get a table of just the random effects with the code below: model &lt;- afex::lmer( rating ~ rater_age * face_age + # fixed effects (1 | rater_id) + (1 | face_id), # random effects data = faux::fr4 ) broom.mixed::tidy(model, effects = &quot;ran_pars&quot;) #&gt; # A tibble: 3 x 4 #&gt; effect group term estimate #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 ran_pars face_id sd__(Intercept) 0.604 #&gt; 2 ran_pars rater_id sd__(Intercept) 0.914 #&gt; 3 ran_pars Residual sd__Observation 1.04 random factor A factor whose levels are taken to represent a proper subset of a population of interest, typically because the observed levels are the result of sampling. If you perform a study where the population of interest is “undergraduates at the University of Glasgow,” you are very unlikely to obtain data from all approximately 20,000 undergraduate students. Instead, you would likely obtain a (hopefully random) sample of undergraduates, with each undergraduate forming a single ‘level’ of the ‘subject’ factor. By treating ‘subject’ as random rather than fixed in your analysis, you will obtain parameter estimates that are closer to the true population values. Random factors are usually contrasted with fixed factors, whose levels are assumed to represent all the levels of interest in a population. random seed A value used to set the initial state of a random number generator. Random seeds are used in random number generation. Each time you generate a random number, the number you get depends on the state of the underlying random number generator. If you set this state to a known value, you will get the same random numbers in the same order. Random seeds are used to make processes that involve random values reproducible. In R, you can set a random seed using the set.seed() function. If you put set.seed() at the start of your script, you will get the same output every time. reactivity Changes in a Shiny app that occur in response to user input. Reactive features of your UI are rendered in the server. relative path The location of a file in relation to the working directory. For example, if your working directory is /Users/me/study/ and you want to refer to a file at /Users/me/study/data/faces.csv, the relative path is data/faces.csv. Use ../ to move up one directory. # the working directory: /Users/me/study/ # read a file inside the wd: /Users/me/study/data/faces.csv qdat &lt;- readr::read_csv(&quot;data/faces.csv&quot;) # read a file outside the wd: /Users/me/other_study/data/exp.csv xdat &lt;- readr::read_csv(&quot;../other_study/data/exp.csv&quot;) Make sure you always use relative paths in an R Markdown document, which automatically sets the working directory to the directory that contains the .Rmd file. Contrast with absolute path. render To create a file (usually an image or PDF) or widget from source code In the context of Shiny apps, render usually means to create the HTML to display in a reactive output from code in the server section. In the context of R Markdown files, knit, render and compile tend to be used interchangeably. repeated measures A dataset has repeated measures if there are multiple measurements taken on the same variable for individual sampling units. See also multilevel. replicability The extent to which the findings of a study can be repeated with new samples from the same population. See also reproducibility. reproducibility The extent to which the findings of a study can be repeated in some other context Reproducibility can be either with new samples from the same population (replicability) or with the same raw data but analyzed by different researchers or by the same researchers on a different occasion (computational or analytical reproducibility). reproducible research Research that documents all of the steps between raw data and results in a way that can be verified. residual error That part of an observation that cannot be captured by the statistical model, and thus is assumed to reflect unknown factors. Mathematically, residual error is defined as the observed value of a variable minus the fitted value for that observation from the model. response variable A variable (in a regression) whose value is assumed to be influenced by one or more predictor variables. In an experimental context, the response variable is often referred to as the dependent variable. right_join A mutating join that keeps all the data from the second (right) table and joins anything that matches from the first (left) table. Figure 26: Right Join X &lt;- tibble( id = 1:5, x = LETTERS[1:5] ) Y &lt;- tibble( id = 2:6, y = LETTERS[22:26] ) Table X Table Y id x 1 A 2 B 3 C 4 D 5 E id y 2 V 3 W 4 X 5 Y 6 Z If there is no matching data in the left table for a row, the values are set to NA. # a is the right table data &lt;- right_join(a, b, by = &quot;id&quot;) id x.x y x.y 4 NA NA D 5 NA NA E 6 NA NA F Order is important for right joins. # b is the right table data &lt;- right_join(b, a, by = &quot;id&quot;) x.x id x.y y NA 1 A TRUE NA 2 B TRUE NA 3 C FALSE See joins for other types of joins and further resources. RStudio An integrated development environment (IDE) that helps you process R code. Download RStudio at https://rstudio.com/ "],["s.html", "S sample scope script semi_join server SESOI set operations Shiny shinydashboard significant simulation single brackets slope standard deviation string sum code", " S sample A subset of the population that you wish to make an inference about through your test. The sample is a smaller group obtained from your population but it is key that the sample is representative of the population. As in most instances it is realistically impossible to test all members of a population, a sample is derived, that represents the population of interest, from the population. The sample should have the same demographic characteristics as the population for example. If your sample is not representative of the population then any conclusions derived from your test are invalid. If the population is small enough to feasibly test in full, e.g. all students in a final year Psychology class, then your sample and the population are the same. For an interesting paper on populations, samples and generalisability, see: Simons, D. J., Shoda, Y., &amp; Lindsay, D. S. (2017). Constraints on Generality (COG): A Proposed Addition to All Empirical Papers. Perspectives on Psychological Science, 12(6), 1123–1128. {doi: 10.1177/1745691617708630}(https://doi.org/10.1177/1745691617708630){target=\"_blank\"}} scope The environment where an object is available The main thing you need to know about scope involves writing your own functions. Objects created inside a function are only available inside the function and not outside. y &lt;- 5 # this y is global x &lt;- function() { y &lt;- 10 # this y is local return(y) } x() # returns the local value of y #&gt; [1] 10 y # returns the global value of y #&gt; [1] 5 If you have arguments to a function, they are local variables inside the function and their values will overwrite any global variables with the same name. y &lt;- 5 # this y is global x &lt;- function(y) { y &lt;- y + 1 # this uses the local value of y return(y) } x(10) # returns 10 + 1 #&gt; [1] 11 y # y is still 5 #&gt; [1] 5 script A plain-text file that contains commands in a coding language, such as R. semi_join A filtering join that returns all rows from the left table where there are matching values in the right table, keeping just columns from the left table. Figure 27: Semi Join This is useful when you have a table of data that contains IDs of data that passes your exclusion criteria. all_data &lt;- tibble( id = 1:5, x = LETTERS[1:5] ) to_keep &lt;- tibble( id = 2:4 ) data &lt;- semi_join(all_data, to_keep, by = &quot;id&quot;) id x 2 B 3 C 4 D See joins for other types of joins and further resources. server This is the part of a Shiny app that works with logic. The server is a function that processes the user’s input in the UI, and allows the app to render appropriate output. See this shiny basics article for more. SESOI Smallest Effect Size of Interest: the smallest effect that is theoretically or practically meaningful See Equivalence Testing for Psychological Research: A Tutorial for a tutorial on methods for choosing an SESOI. Lakens, D. (2017a). Equivalence tests: A practical primer for t tests, correlations, and meta-analyses. Social Psychological &amp; Personality Science, 8, 355–362. doi:10.1177/1948550617697177 set operations Functions that compare two tables and return rows that match (intersect), are in either table (union), or are in one table but not the other (setdiff). The examples below use two small datasets. a has ids 1 to 5, and b has ids 3 to 7. a &lt;- tibble(id = 1:5) b &lt;- tibble(id = 3:7) intersect() returns all rows in two tables that match exactly. The columns don’t have to be in the same order. dplyr::intersect(a, b) #&gt; # A tibble: 3 x 1 #&gt; id #&gt; &lt;int&gt; #&gt; 1 3 #&gt; 2 4 #&gt; 3 5 union() returns all the rows from both tables, removing duplicate rows. dplyr::union(a, b) #&gt; # A tibble: 7 x 1 #&gt; id #&gt; &lt;int&gt; #&gt; 1 1 #&gt; 2 2 #&gt; 3 3 #&gt; 4 4 #&gt; 5 5 #&gt; 6 6 #&gt; 7 7 setdiff returns rows that are in the first table, but not in the second table. dplyr::setdiff(a, b) #&gt; # A tibble: 2 x 1 #&gt; id #&gt; &lt;int&gt; #&gt; 1 1 #&gt; 2 2 If you’ve forgotten to load dplyr or the tidyverse, base R also has these functions. You will either get an error message or unexpected output if you try to use them with data tables. Shiny An R package that builds interactive web apps Shiny website psyTeachR Shiny Tutorials shinydashboard A package for R that builds on Shiny for more flexible and visually appealing UIs. Shiny Dashboard or shinydashboard can be installed with install.packages(\"shinydashboard\"), and can be loaded with library(shinydashboard). The shinydashboard documentation is a great introduction to this package. significant The conclusion when the p-value is less than the critical alpha. simulation Generating data from summary parameters single brackets A pair of square brackets used to select a subset from a container like a list, data frame, or matrix (e.g., data[1, ]). secret_code &lt;- c(16, 19, 25, 20, 5, 1, 3, 8, 18) LETTERS[secret_code] #&gt; [1] &quot;P&quot; &quot;S&quot; &quot;Y&quot; &quot;T&quot; &quot;E&quot; &quot;A&quot; &quot;C&quot; &quot;H&quot; &quot;R&quot; See brackets for an explanation of the difference between single and double brackets. slope A quantity that captures how much change in one variable is associated with a unit increase in another variable. If you have a slope of 3, that means that a unit increase in the \\(X\\) variable is associated with a 3 unit change in the \\(Y\\) variable. If you have a slope of -1/2, then a unit increase in the \\(X\\) variable is associated with a decrease of 1/2 in the \\(Y\\) variable. standard deviation A descriptive statistic that measures how spread out data are relative to the mean. If the data points are further from the mean, there is a higher standard deviation. Standard deviation is calculated as the square root of the variance. Figure 28: Normal distributions with means of 0 and SDs of 1 (red), 2 (blue) and 3 (purple). string A piece of text inside of quotes. For example, \"I sense the rains down in Africa\" is a string. Numbers inside of quotes can be a string; \"19\" is a string, while 19 is not. Strings are a character data type. sum code A coding scheme for categorical variables that compares the mean for each level to the overall mean. "],["t.html", "T tabular data tibble tidy data tidyverse transparency treatment code true negative true positive two-tailed Type I Error Type II Error", " T tabular data Data in a rectangular table format, where each row has an entry for each column. Tabluar data in R are usually in a data frame or tibble. #&gt; year sex name n rank #&gt; 1 1996 F Sophie 7087 1 #&gt; 2 1996 F Chloe 6824 2 #&gt; 3 1996 F Jessica 6711 3 #&gt; 4 1996 F Emily 6415 4 #&gt; 5 1996 F Lauren 6299 5 #&gt; 6 1996 F Hannah 5916 6 tibble A container for tabular data with some different properties to a data frame Tibbles are almost exactly like the base R data.frame container type, but has some special printing functions, does not coerce character columns to factors, and does not typically use row names. # display the mtcars data frame mtcars #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 #&gt; Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 #&gt; Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 #&gt; Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 #&gt; Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 #&gt; Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 #&gt; Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 #&gt; Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 #&gt; Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 #&gt; Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 #&gt; Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 #&gt; Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 #&gt; Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 #&gt; AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 #&gt; Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 #&gt; Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 #&gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 #&gt; Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 #&gt; Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 #&gt; Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 #&gt; Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 #&gt; Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 #&gt; Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 # convert the mtcars data frame to a tibble tibble::as_tibble(mtcars, rownames = &quot;name&quot;) #&gt; # A tibble: 32 x 12 #&gt; name mpg cyl disp hp drat wt qsec vs am gear carb #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 #&gt; 2 Mazda RX4 Wag 21 6 160 110 3.9 2.88 17.0 0 1 4 4 #&gt; 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 4 Hornet 4 Drive 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 #&gt; 5 Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 #&gt; 7 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 #&gt; 8 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 #&gt; 9 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 #&gt; 10 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 #&gt; # … with 22 more rows tidy data A format for data that maps the meaning onto the structure. Tidy data has three rules: Each variable must have its own column Each observation must have its own row Each value must have its own cell tidyverse A set of R packages that help you create and work with tidy data The tidyverse can be loaded with library(tidyverse) and loads the following packages: {ggplot2} for data visualisation {tibble} for data tables {tidyr} for tidy data {readr} for reading in data {purrr} for iteration {dplyr} for data wrangling {stringr} for string manipulation {forcats} for factors Compare with base R transparency The degree to which all the steps and decisions in a study have been documented and made available for verification. treatment code A coding scheme for categorical variables that creates (n_levels -1) dichotomous variables where each level of the categorical variable is contrasted to a reference level. Also referred to as dummy-coding. true negative When a test concludes there is no effect when there is really is no effect true positive When a test concludes there is an effect when there is really is an effect two-tailed A statistical test for which the critical region consists of all values of the test statistic greater than a given value plus all values less than another given value. See p-value for a comparison of one-tailed and two-tailed tests. Type I Error A false positive; When a test concludes there is an effect when there is really is no effect Type II Error A false negative; When a test concludes there is no effect when there is really is an effect "],["u.html", "U UI uniform distribution univariate", " U UI The User Interface. This usually refers to a Shiny App as the user will see it. The UI is defined as an object using (e.g.) fluidPage() or dashboardPage(). The UI is in contrast to the server object, which processes information the user inputs (e.g. via widgets) to the UI, and can reactively render the app’s UI. This means that the UI can look completely different depending on the actions of the user. See this shiny basics article for more. uniform distribution A distribution where all numbers in the range have an equal probability of being sampled x &lt;- runif(100000, min = 0, max = 100) Figure 29: Uniform Distribution univariate Relating to a single variable. Usually used in the context of the analysis of a single dependent variable. Table 3: Uniivariate data with 3 scores on the same task per person id stroop_1 stroop_2 stroop_3 S1 14 11 10 S2 12 14 8 S3 10 12 8 S4 10 12 7 S5 13 10 9 Contrast with multivariate. "],["v.html", "V value variable variance vector vectorized version control", " V value A single number or piece of data. In a tidy dataset, each cell contains only one value. The age column contains 3 values: mean, minimum and maximum. library(dplyr) library(tidyr) untidy &lt;- data.frame( group = c(&quot;A&quot;, &quot;B&quot;), age = c(&quot;20.4 [18-25]&quot;, &quot;19.9 [18-24]&quot;) ) group age A 20.4 [18-25] B 19.9 [18-24] tidy &lt;- untidy %&gt;% separate(age, c(&quot;mean&quot;, &quot;min&quot;, &quot;max&quot;), sep = &quot;( \\\\[|-|\\\\])&quot;, extra = &quot;drop&quot;) group mean min max A 20.4 18 25 B 19.9 18 24 variable A word that identifies and stores the value of some data for later use. Variables in R are usually referred to as objects. See the definition for object. variance A descriptive statistic for how much an average data point varies from the mean. data &lt;- c(1,2,3,4,5,6,7,8,9) var(data) #&gt; [1] 7.5 Variance is equal to standard deviation squared. sd(data)^2 #&gt; [1] 7.5 You calculate variance by summing the squared differences between each data point and their mean (sum(diff^2)) and dividing this by the number of data points minus 1 ((n-1)) m &lt;- mean(data) # calculate the mean diff &lt;- data - m # difference between each data point and the mean n &lt;- length(data) # number of data points sum(diff^2)/(n-1) # variance #&gt; [1] 7.5 vector A type of data structure that is basically a list of things like T/F values, numbers, or strings. It can get very complicated (see Ch 20 of R for Data Science for a thorough explanation), but at first you just need to be able to understand that the following things are examples of vectors: # use the c() function to make a vector of strings or numbers liit_ingredients &lt;- c(&quot;vodka&quot;, &quot;gin&quot;, &quot;rum&quot;, &quot;tequila&quot;, &quot;triple sec&quot;, &quot;orange juice&quot;, &quot;coke&quot;, &quot;sour mix&quot;) fun_to_play_at &lt;- c(25, 13, 3, 1) # the colon between two integers gives you all the numbers from the first to the last integer likert &lt;- 1:7 The variable letters is a built-in vector with the latin letters in order. You can select part of a vector by putting the numeric location (or index) of what element you want inside of square brackets after the vector. You can even put a vector of numbers inside the square brackets to select several elements. letters[26] #&gt; [1] &quot;z&quot; letters[1:5] #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; letters[fun_to_play_at] #&gt; [1] &quot;y&quot; &quot;m&quot; &quot;c&quot; &quot;a&quot; vectorized An operator or function that acts on each element in a vector # Add 10 to each element in the vector a a &lt;- 1:5 a + 10 #&gt; [1] 11 12 13 14 15 # paste &quot;!&quot; to the end of each element in the vector b b &lt;- c(&quot;Hey&quot;, &quot;You&quot;) paste0(b, &quot;!&quot;) #&gt; [1] &quot;Hey!&quot; &quot;You!&quot; version control A way to save a record of changes to your files. Git is one type of version control that is most commonly used with RStudio. GitHub is a cloud-based service for storing and sharing your version controlled files. Set up git and github with RStudio. "],["w.html", "W whitespace wide widget within subjects working directory", " W whitespace Spaces, tabs and line breaks R mostly ignores whitespace, so you can use it to help you organise your code. # a and b are identical a &lt;- list(ctl = &quot;Control Condition&quot;, exp1 = &quot;Experimental Condition 1&quot;, exp2 = &quot;Experimental Condition 2&quot;) # but b is much easier to read b &lt;- list(ctl = &quot;Control Condition&quot;, exp1 = &quot;Experimental Condition 1&quot;, exp2 = &quot;Experimental Condition 2&quot;) You may also encounter the term in the context of formatting statistics. For example, the APA recommends using whitespace around equal signs. with whitespace: t(49) = 1.50, p = .140, d = 0.20 without whitespace: t(49)=1.50, p=.140, d=0.20 wide Data where all of the observations about one subject are in the same row Table 4: Wide data id Q1 Q2 Q3 A 1 2 3 B 4 5 6 Contrast with long data. widget A interactive web element, like a dropdown menu or a slider. See a great overview of widgets at the RStudio Shiny tutorial. In shiny apps, a widget is created by its function. The first argument is the name you will use in the code for referring to that widget and its value, so make sure it’s a unique, descriptive name like plot_color or group1_label. The second argument is the label, which is a string like \"Plot colour\" or \"Label for the first group\" (it can also be an empty string like \"\"). within subjects Varying such that each unit of observation has more than one value For example, imagine an experiment where you test subjects with easy, medium, and hard tasks. This experiment has one factor, task difficulty, which is within subjects because each subject experiences all three levels: easy, medium, and hard. This experiment may also be described as “within subjects.” Contrast with between subjects. working directory The filepath where R is currently reading and writing files. If you are working in a project, the working directory is usually the main project directory. So if you want to save a file into a folder called “data” in that project folder, you can use a relative path, which is automatically appended to the working directory, such as readr::write_csv(my_data, \"data/my_data.csv\"). getwd() .html# get the current working directory setwd(&quot;~/r/myfiles&quot;) .html# change the working directory Never set or change your working directory in a script. "],["x.html", "X", " X "],["y.html", "Y YAML", " Y YAML A structured format for information You’ll most commonly encounter YAML in the header of an R Markdown document. It consists of key and value pairs separated by a colon, where the key is an unquoted label, like title, and the value is quoted or unquoted text like \"My Document\" or a further list of keys and values. --- title: &quot;My Document&quot; subtitle: &quot;It&#39;s Just a Demo&quot; author: &quot;Me&quot; date: &quot;2021-03-27&quot; output: html_document: theme: spacelab highlight: tango toc: true toc_float: collapsed: false smooth_scroll: false toc_depth: 3 number_sections: false --- The spacing and line breaks need to be exactly right or YAML won’t parse and you will get error messages when you try to knit the R Markdown document. For example, the header above won’t knit if you change the spacing before theme: spacelab like this: output: html_document: theme: spacelab YAML stands for YAML Ain’t Markup Language. "],["z.html", "Z", " Z "]]
